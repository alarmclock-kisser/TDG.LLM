@page "/"
@page "/home"

@using Microsoft.AspNetCore.Components.Web
@using TDG.LLM.Client
@using TDG.LLM.Shared
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using Radzen
@using Radzen.Blazor
@inject ApiClient ApiClient
@inject GeminiApiClient GeminiApiClient
@inject IJSRuntime JSRuntime

<h1 style="font-family: 'Arial Black'">TDG.LLM WebApp -- Home</h1>

<RadzenStack Orientation="Orientation.Horizontal" Gap="1rem" Style="margin-bottom:1rem; align-items:flex-end; flex-wrap:wrap;">
    <RadzenDropDown @bind-Value="SelectedGeminiModel" Data="GeminiModels" Style="width:220px;" Placeholder="Gemini Modell" Change="OnGeminiModelChanged" />
    <RadzenCheckBox TriState="false" @bind-Value="UseAllFrames" Change="@(async (bool v)=> await OnUseAllFramesChanged(v))" />
    <RadzenLabel Text="Alle Frames senden" Style="font-size:12px;" />
</RadzenStack>

<!-- Bildanzeige (resizable + context menu) -->
<div id="imageContainer" @oncontextmenu="OnImageContextMenu" style="position:relative; width:@ImageWidthPx; height:@ImageHeightPx; background:#222; display:flex; align-items:center; justify-content:center; margin-bottom:1rem; border:1px solid #444; border-radius:4px; overflow:hidden;">
    @if (!string.IsNullOrEmpty(CurrentImageBase64))
    {
        <img src="@CurrentImageBase64" style="max-width:100%; max-height:100%; object-fit:contain;" />
    }
    else
    {
        <span style="color:#888;">Kein Bild ausgewählt</span>
    }
    <div id="resizeHandle" title="Größe ändern" style="position:absolute; right:4px; bottom:4px; width:16px; height:16px; background:#555; border:1px solid #999; cursor:nwse-resize; border-radius:3px; display:flex; align-items:center; justify-content:center; font-size:9px; color:#ccc; user-select:none;">↔</div>
</div>

<!-- Infos: Name / Guid / Size / DataSize -->
<RadzenPanel Style="width:60%; margin-bottom:1rem;" AllowCollapse="true" Text="Bild Infos" Collapsed="true">
    <ChildContent>
        <RadzenStack Orientation="Orientation.Vertical" Gap="4px">
            <RadzenLabel Text="Datei:" />
            <RadzenLabel Text="@(CurrentImageInfo?.FilePath ?? "-")" Style="font-weight:bold" />
            <RadzenLabel Text="GUID:" />
            <RadzenLabel Text="@(CurrentImageInfo?.Id.ToString() ?? "-")" />
            <RadzenLabel Text="Auflösung:" />
            <RadzenLabel Text="@ImageResolutionText" />
            <RadzenLabel Text="Datenmenge (aktuelles Frame):" />
            <RadzenLabel Text="@ImageDataSizeKBText" />
        </RadzenStack>
    </ChildContent>
</RadzenPanel>

<!-- Frame Navigation -->
<RadzenNumeric @bind-Value="CurrentFrame"
               Min="0"
               Max="@(CurrentImageInfo?.FrameCount > 0 ? CurrentImageInfo.FrameCount - 1 : 0)"
               Style="width:140px; margin-bottom:1rem;"
               Change="@(async (int v) => await OnFrameChanged(v))"
               Placeholder="Frame" />

<!-- Bildliste -->
<RadzenListBox TValue="Guid" Data="@ImageListEntries" @bind-Value="SelectedImageId"
               TextProperty="DisplayText" ValueProperty="Id"
               Style="width:60%; height:220px; margin-bottom:1rem;"
               Change="@OnImageSelected" />

<!-- Aktionen -->
<RadzenStack Orientation="Orientation.Horizontal" Gap="1rem" Style="margin-bottom:1rem; flex-wrap:wrap; align-items:center;">
    <RadzenUpload ChooseText="Bild wählen" Accept="image/*" Multiple="false" Auto="false" Change="OnUploadChange" Style="min-width:160px;" />
    <RadzenButton Text="Entfernen" ButtonStyle="ButtonStyle.Danger" Icon="delete" Disabled="@(SelectedImageId == Guid.Empty)" Click="OnRemoveClick" />
    <RadzenButton Text="Download" Icon="download" Disabled="@(SelectedImageId == Guid.Empty)" Click="OnDownloadClick" />
    <RadzenDropDown TValue="string" Data="@DownloadFormats" @bind-Value="SelectedFormat" Style="width:120px;" />
    <RadzenButton Text="Base64 anzeigen" Icon="code" Disabled="@(SelectedImageId == Guid.Empty)" Click="OnShowBase64" />
</RadzenStack>

<!-- Prompt an Gemini -->
<RadzenTextBox @bind-Value="PromptText" Placeholder="Frage an Gemini..." Style="width:60%; margin-bottom:0.5rem;" />
<RadzenStack Orientation="Orientation.Horizontal" Gap="0.5rem" Style="margin-bottom:1rem; align-items:center; flex-wrap:wrap;">
    <RadzenButton Text="Fragen" Icon="send" ButtonStyle="ButtonStyle.Primary" Disabled="@(SelectedImageId == Guid.Empty)" Click="OnPromptSend" />
    <RadzenButton Text="Dokument Analyse (JSON)" Icon="article" ButtonStyle="ButtonStyle.Secondary" Disabled="@(SelectedImageId == Guid.Empty)" Click="OnStructuredExtract" />
</RadzenStack>

<!-- Antwort / Base64 Ausgabe -->
<RadzenTextArea @bind-Value="OllamaResponse" ReadOnly="true" Style="width:60%; min-height:180px; margin-bottom:1rem; font-family:monospace;" />

@code {
    private List<ImageObjInfo> ImageList = new();
    private List<ImageListEntry> ImageListEntries = new();
    private Guid SelectedImageId = Guid.Empty;
    private ImageObjInfo? CurrentImageInfo => ImageList.FirstOrDefault(x => x.Id == SelectedImageId);
    private int CurrentFrame = 0;
    private string CurrentImageBase64 = string.Empty;
    private string PromptText = string.Empty;
    private string OllamaResponse = string.Empty;
    private string[] DownloadFormats = new[] { "png", "jpg", "bmp" };
    private string SelectedFormat = "png";

    // Gemini model selection
    private string SelectedGeminiModel = "gemini-1.5-flash";
    private string[] GeminiModels = new[] { "gemini-1.5-flash", "gemini-1.5-pro", "gemini-1.5-flash-8b", "gemini-1.0-pro", "gemini-2.0-flash", "gemini-2.0-pro" };
    private bool UseAllFrames = false;

    // Derived info
    private string ImageResolutionText => CurrentImageInfo == null || CurrentImageInfo.Id == Guid.Empty ? "-" : _currentWidth > 0 ? $"{_currentWidth} x {_currentHeight}px" : "?";
    private string ImageDataSizeKBText => _lastFrameBytes > 0 ? $"{(_lastFrameBytes / 1024.0):F1} kB" : "-";

    // Tracking current frame meta
    private int _currentWidth = 0;
    private int _currentHeight = 0;
    private int _lastFrameBytes = 0;

    // Resizing state
    private int ImageWidth = 900;
    private int ImageHeight = (int)(900 * 9.0 / 16.0);
    private string ImageWidthPx => ImageWidth + "px";
    private string ImageHeightPx => ImageHeight + "px";
    private bool _resizeJsInitialized = false;

    private class ImageListEntry
    {
        public Guid Id { get; set; }
        public string DisplayText { get; set; } = string.Empty;
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadImageList();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_resizeJsInitialized)
        {
            await JSRuntime.InvokeVoidAsync("initImageResizer", "imageContainer", "resizeHandle");
            _resizeJsInitialized = true;
        }
    }

    private void BuildImageListEntries()
    {
        ImageListEntries = ImageList.Select(i => new ImageListEntry
        {
            Id = i.Id,
            DisplayText = $"{(string.IsNullOrWhiteSpace(i.FilePath) ? "[Unbenannt]" : i.FilePath)} ({i.Id.ToString()[..8]})"
        }).ToList();
    }

    private async Task LoadImageList()
    {
        ImageList = (await ApiClient.GetImageListAsync()).ToList();
        BuildImageListEntries();
        if (ImageList.Count == 0)
        {
            SelectedImageId = Guid.Empty;
            CurrentImageBase64 = string.Empty;
            ResetFrameMeta();
            StateHasChanged();
            return;
        }
        if (!ImageList.Any(i => i.Id == SelectedImageId))
        {
            SelectedImageId = ImageList[0].Id;
        }
        CurrentFrame = 0;
        await LoadCurrentImage();
    }

    private void ResetFrameMeta()
    {
        _currentWidth = 0;
        _currentHeight = 0;
        _lastFrameBytes = 0;
    }

    private async Task LoadCurrentImage()
    {
        if (SelectedImageId == Guid.Empty)
        {
            CurrentImageBase64 = string.Empty;
            ResetFrameMeta();
            StateHasChanged();
            return;
        }
        var data = await ApiClient.GetBase64String(SelectedImageId, CurrentFrame);
        if (!string.IsNullOrEmpty(data.Base64String))
        {
            CurrentImageBase64 = $"data:image/png;base64,{data.Base64String}";
            _currentWidth = data.Width;
            _currentHeight = data.Height;
            _lastFrameBytes = (data.Base64String.Length * 3) / 4; // grob dekodierte Byteanzahl
        }
        else
        {
            CurrentImageBase64 = string.Empty;
            ResetFrameMeta();
        }
        StateHasChanged();
    }

    private async Task OnImageSelected(object value)
    {
        if (value is Guid g)
        {
            SelectedImageId = g;
            CurrentFrame = 0;
            await LoadCurrentImage();
        }
    }

    private async Task OnFrameChanged(int value)
    {
        CurrentFrame = value;
        await LoadCurrentImage();
    }

    private async Task OnUploadChange(UploadChangeEventArgs args)
    {
        var file = args.Files?.FirstOrDefault();
        if (file == null) return;
        var info = await ApiClient.UploadImageAsync(file);
        if (info != null && info.Id != Guid.Empty)
        {
            SelectedImageId = info.Id;
            await LoadImageList();
            await LoadCurrentImage();
        }
        else
        {
            await LoadImageList();
        }
    }

    private async Task OnRemoveClick()
    {
        if (SelectedImageId == Guid.Empty) return;
        await ApiClient.DeleteImageAsync(SelectedImageId);

        await LoadImageList();
    }

    private async Task OnDownloadClick()
    {
        if (SelectedImageId == Guid.Empty) return;
        // Absolute URL zur API (stellt sicher, dass nicht die Blazor-WebApp getroffen wird)
        var url = $"{ApiClient.BaseUrl}/api/image/raw/{SelectedImageId}/{CurrentFrame}/{SelectedFormat}";
        await JSRuntime.InvokeVoidAsync("downloadImageFrame", url);
    }

    private void OnImageContextMenu(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        // Kein spezielles Kontextmenü blockieren -> Browser default (Speichern unter)
    }

    private async Task OnPromptSend()
    {
        if (SelectedImageId == Guid.Empty) return;

        OllamaResponse = "Warte auf Antwort...";
        StateHasChanged();
        var inlineImages = new List<GeminiApiClient.InlineImage>();
        if (UseAllFrames && CurrentImageInfo != null)
        {
            // hole alle Frames
            for (int f = 0; f < CurrentImageInfo.FrameCount; f++)
            {
                var frameData = await ApiClient.GetBase64String(SelectedImageId, f);
                if (!string.IsNullOrEmpty(frameData.Base64String)) inlineImages.Add(new(frameData.Base64String, $"image/{(string.IsNullOrWhiteSpace(frameData.Format)?"png":frameData.Format)}"));
            }
        }
        else
        {
            var imgData = await ApiClient.GetBase64String(SelectedImageId, CurrentFrame);
            if (!string.IsNullOrEmpty(imgData.Base64String)) inlineImages.Add(new(imgData.Base64String, $"image/{(string.IsNullOrWhiteSpace(imgData.Format)?"png":imgData.Format)}"));
        }
        var answer = await GeminiApiClient.GenerateWithModelAsync(SelectedGeminiModel, new[] { PromptText }, inlineImages, default);
        OllamaResponse = answer; StateHasChanged();
    }

    private async Task OnShowBase64()
    {
        if (SelectedImageId == Guid.Empty) return;
        var data = await ApiClient.GetBase64String(SelectedImageId, CurrentFrame);
        if (!string.IsNullOrEmpty(data.Base64String))
        {
            OllamaResponse = data.Base64String;
            StateHasChanged();
        }
    }

    private Task OnGeminiModelChanged(object _)
    {
        GeminiApiClient.SetModel(SelectedGeminiModel);
        return Task.CompletedTask;
    }

    private Task OnUseAllFramesChanged(bool v)
    {
        UseAllFrames = v;
        return Task.CompletedTask;
    }

    private static string CleanModelJson(string raw)
    {
        if (string.IsNullOrWhiteSpace(raw)) return raw;
        var s = raw.Replace("\r", "");
        // Entferne Markdown Codefences ```json / ```
        if (s.Contains("```"))
        {
            s = System.Text.RegularExpressions.Regex.Replace(s, "```json", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            s = s.Replace("```", "");
        }
        // Trimme Backticks / Whitespace
        s = s.Trim('`', ' ', '\n', '\t');
        // Versuche nur den JSON Block zu extrahieren
        int first = s.IndexOf('{'); int last = s.LastIndexOf('}');
        if (first >= 0 && last > first)
        {
            s = s.Substring(first, last - first + 1);
        }
        return s.Trim();
    }

    // Structured extraction -> returns JSON file
    private async Task OnStructuredExtract()
    {
        if (SelectedImageId == Guid.Empty) return;

        // Read Properties\extractionPrompt.txt as prompt
        var promptFile = Path.Combine(AppContext.BaseDirectory, "Properties", "extractionPrompt.txt");
        string prompt = File.Exists(promptFile) ? File.ReadAllText(promptFile) : "Extrahiere strukturierte Felder als JSON.";
        var imgs = new List<GeminiApiClient.InlineImage>();
        if (UseAllFrames && CurrentImageInfo != null)
        {
            for (int f = 0; f < CurrentImageInfo.FrameCount; f++)
            {
                var frameData = await ApiClient.GetBase64String(SelectedImageId, f);
                if (!string.IsNullOrEmpty(frameData.Base64String)) imgs.Add(new(frameData.Base64String, $"image/{(string.IsNullOrWhiteSpace(frameData.Format)?"png":frameData.Format)}"));
            }
        }
        else
        {
            var frameData = await ApiClient.GetBase64String(SelectedImageId, CurrentFrame);
            if (!string.IsNullOrEmpty(frameData.Base64String)) imgs.Add(new(frameData.Base64String, $"image/{(string.IsNullOrWhiteSpace(frameData.Format)?"png":frameData.Format)}"));
        }
        var raw = await GeminiApiClient.GenerateWithModelAsync(SelectedGeminiModel, new[] { prompt }, imgs, default);
        var cleaned = CleanModelJson(raw);
        // Versuch: rohen Text als JSON Parsen, falls nicht -> wrap
        string jsonOut;
        try { System.Text.Json.JsonDocument.Parse(cleaned); jsonOut = cleaned; }
        catch { jsonOut = System.Text.Json.JsonSerializer.Serialize(new { result = cleaned }); }
        var bytes = System.Text.Encoding.UTF8.GetBytes(jsonOut);
        var b64 = Convert.ToBase64String(bytes);
        await JSRuntime.InvokeVoidAsync("downloadImageFrame", $"data:application/json;base64,{b64}");
    }
}

<script>
    window.initImageResizer = (containerId, handleId) => {
        const el = document.getElementById(containerId);
        const handle = document.getElementById(handleId);
        if (!el || !handle) return;
        let startX = 0, startY = 0, startW = 0, startH = 0, resizing = false;
        const minW = 200, minH = 150;
        handle.addEventListener('mousedown', e => {
            e.preventDefault();
            startX = e.clientX;
            startY = e.clientY;
            const rect = el.getBoundingClientRect();
            startW = rect.width;
            startH = rect.height;
            resizing = true;
            document.body.style.userSelect = 'none';
        });
        window.addEventListener('mousemove', e => {
            if (!resizing) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            let newW = startW + dx;
            let newH = startH + dy;
            if (newW < minW) newW = minW;
            if (newH < minH) newH = minH;
            el.style.width = newW + 'px';
            el.style.height = newH + 'px';
        });
        window.addEventListener('mouseup', () => {
            if (resizing) {
                resizing = false;
                document.body.style.userSelect = '';
            }
        });
    };
    window.downloadImageFrame = async (url) => {
        try {
            if (url.startsWith('data:')) {
                const a = document.createElement('a');
                a.href = url;
                a.download = 'extraction.json';
                document.body.appendChild(a);
                a.click();
                a.remove();
                return;
            }
            const resp = await fetch(url);
            if (!resp.ok) {
                console.error('Download failed', resp.status, resp.statusText);
                return;
            }
            const disposition = resp.headers.get('content-disposition');
            let fileName = 'image';
            if (disposition && disposition.indexOf('filename=') !== -1) {
                const match = /filename="?([^";]+)"?/i.exec(disposition);
                if (match && match[1]) {
                    fileName = match[1];
                }
            } else {
                const parts = url.split('/');
                const last = parts[parts.length - 1];
                if (last.indexOf('.') > -1) fileName = last;
            }
            const blob = await resp.blob();
            const blobUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(blobUrl), 2000);
        } catch (e) {
            console.error('Download exception', e);
        }
    };
</script>
